# 如何避免出现僵尸进程在容器中
## 僵尸进程的危害以及产生原因
僵尸进程表示，进程已经死亡（结束），但仍然以某种方式活着。实际上，说这些进程死了，是因为其资源（内存、与外设的连接，等等）已经释放，因此它们无法也决不会再次运行。说它们仍然活着，是因为进程表中仍然有对应的表项，所以用top可以看到他们的状态。

僵尸进程的存在会严重限制后续的新进程的产生，如果对容器的pid.max系数进行修改后。进程数大于pid.max后，OS将无法产生新的进程。

僵尸进程产生的原因? 其原因在于UNIX操作系统下进程创建和销毁的方式。在两种事件发生时，程序将终止运行。第一，程序必须由另一个进程或一个用户杀死（通常是通过发送SIGTERM或SIGKILL信号来完成，这等价于正常地终止进程）；进程的父进程在子进程终止时必须调用或已经调用**wait4（读做wait for）系统调用**。 这相当于向内核证实父进程已经确认子进程的终结。该系统调用使得内核可以释放为子进程保留的资源。只有在第一个条件发生（程序终止）而第二个条件不成立的情况下（ wait4），才会出现“僵尸”状态。长话短说，就是父进程退出前没有掉用 wait4 函数。

## wait 和 waitpid的函数参数和理解
```C
// 会阻塞
pid_t wait(int *status) 　　　　
 
// 不会阻塞
pid_t waitpid(pid_t pid, int *status, int options)
```

`wait函数`：
进程一旦调用了wait，就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。
The wait() system call suspends execution of the calling process until one of its children terminates. The call wait(&status) is equivalent to: waitpid(-1, &status, 0);

参数status：
用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。但如果我们对这个子进程是如何死掉的毫不在意，只想把这个僵尸进程消灭掉，（事实上绝大多数情况下，我们都会这样想），我们就可以设定这个参数为NULL，如pid = wait(NULL);
 
返回值：
如果成功，wait会返回被收集的子进程的进程ID
如果调用进程没有子进程，调用就会失败，此时wait返回-1，同时errno被置为ECHILD。　

`waitpid函数`
参数：(status同上)　　 　　
 
pid:从参数的名字pid和类型pid_t中就可以看出，这里需要的是一个进程ID。但当pid取不同的值时，在这里有不同的意义。 --> 也是骚操作还得取个绝对值。。。　　　　
pid > 0时，只等待进程ID等于pid的子进程，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束,waitpid就会一直等下去。
 
pid = -1时，等待任何一个子进程退出，没有任何限制，此时waitpid和wait的作用一模一样。 　　
 
pid = 0时，等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会对它做任何理睬。
 
pid < -1时，等待一个指定进程组中的任何子进程，这个进程组的ID等于pid的**绝对值。** 

options: options提供了一些额外的选项来控制waitpid，选项有点多，来几个常用的，多个options可以用 ｜ 进行连接。
WNOHANG：函数立刻返回如果没有子进程退出的话
WUNTRACED：子进程停止也返回

比如：
ret=waitpid(-1,NULL,WNOHANG | WUNTRACED); 　　
 
如果我们不想使用它们，也可以把options设为0，如： 　　
ret=waitpid(-1,NULL,0); 　　

返回值：
* 当正常返回的时候，waitpid返回收集到的子进程的进程ID；
 
* 如果设置了选项WNOHANG，而调用中waitpid发现没有已退出的子进程可收集，则返回0； 　　 　　
 
* 如果调用中出错，则返回-1，这时errno会被设置成相应的值以指示错误所在；当pid所指示的子进程不存在，或此进程存
在，但不是调用进程的子进程，waitpid就会出错返回，这时errno被设置为ECHILD 　　

##  区别和用处
调用 wait＆waitpid 来处理终止的子进程：
  pid_t wait(int * status); 
  pid_t waitpid(pid_t pid,int * status, int options); 
两个函数都返回两个值：函数的返回值和终止的子进程ID，而子进程终止的状态则是通过status指针返回的。
wait＆waitpid 的区别是显而易见的，wait等待第一个终止的子进程，而waitpid则可以指定等待特定的子进程。
这的区别可能会在下面这种情况时表现得更加明显：
   当同时有5个客户连上服务器，也就是说有五个子进程分别对应了5个客户，此时，五个客户几乎在同时请求终止，这样一来，几乎同时，五个FIN发向服务器，同样的，五个SIGCHLD信号到达服务器，然而，UNIX的信号往往是不会排队的，显然这样一来，信号处理函数将只会执行一次，残留剩余四个子进程作为僵尸进程驻留在内核空间。此时，正确的解决办法是利用waitpid(-1, &stat, WNOHANG)防止留下僵尸进程。
其中的pid为－1表明等待任一个子进程，而WNOHANG选择项通知内核在没有已终止进程项时不要阻塞。

## 思考
如果容器的 init 进程创建了子进程 B，B 又创建了自己的子进程 C。如果 C 运行完之后，退出成了僵尸进程，B 进程还在运行，而容器的 init 进程还在不断地调用 waitpid()，那 C 这个僵尸进程可以被回收吗？
不会回收，waitpid 仅等待直接 children 的状态变化。
为什么要这设计僵尸状体呢？
留给父进程一次机会，查看子进程的 PID、终止状态（退出码、终止原因，比如是信号终止还是正常退出等）、资源使用信息。如果子进程直接消失，那么父进程没有机会掌握子进程的具体终止情况。一般情况下，程序逻辑可能会依据子进程的终止情况做出进一步处理：比如 Nginx Master 进程获知 Worker 进程异常退出，则重新拉起来一个 Worker 进程。    　　
 