# IO模型
## 阻塞、非阻塞、多路复用
- 阻塞 I/O 在等待数据阶段，如果此时没有数据可读，将发生阻塞。
- 非阻塞 I/O 在等待数据阶段，如果此时没有数据可读，将返回 0，通常配合轮询操作直到数据可读，这会导致频繁地发生上下文的切换操作。（陷入内核态？）
- 多路复用在等待数据阶段不再使用 read 系统调用，而是使用 select 系统调用，在复制数据阶段才使用 read 系统调用，而 select 系统调用在没有数据可读的情况下，同样会发生阻塞。



## 多路复用
一个线程来处理所有打开的fs。
多路是指？多个业务方（句柄）并发下来的 IO 。
复用是指？复用这一个后台处理程序。

### 用户态模拟一个IO多路复用
```GO
while True:
    for each 句柄数组 {
        read/write(fd, /* 参数 */)
    }
    sleep(1s)
```
通过轮巡的方式来查看fd中有无数据。但会有卡死的风险
默认情况下，我们 create 出的句柄是阻塞类型的。我们读数据的时候，如果数据还没准备好，是会需要等待的，当我们写数据的时候，如果还没准备好，默认也会卡住等待。所以，在上面伪代码第三行是可能被直接卡死，而导致整个线程都得到不到运行。

举个例子，现在有 11，12，13 这 3 个句柄，现在 11 读写都没有准备好，只要 read/write(11, /*参数*/) 就会被卡住，但 12，13 这两个句柄都准备好了，那遍历句柄数组 11，12，13 的时候就会卡死在前面，后面 12，13 则得不到运行。这不符合我们的预期，因为我们 IO 多路复用的 loop 线程是公共服务，不能因为一个 fd 就直接瘫痪。

只需要把 fd 都设置成非阻塞模式。这样 read/write 的时候，如果数据没准备好，返回 EAGIN 的错误即可，不会卡住线程，从而整个系统就运转起来了。比如上面句柄 11 还未就绪，那么 read/write(11, /*参数*/) 不会阻塞，只会报个 EAGIN 的错误，这种错误需要特殊处理，然后 loop 线程可以继续执行 12，13 的读写。

这样还是有问题，因为默认加了1s的sleep，系统吞吐量不高。如果不加sleep，那么cpu就做了好多无用功，如果没有数据到达的话。

我们再梳理下 IO 多路复用的需求和原理。IO 多路复用就是 1 个线程处理 多个 fd 的模式。我们的要求是：这个 “1” 就要尽可能的快，避免一切无效工作，要把所有的时间都用在处理句柄的 IO 上，不能有任何空转，sleep 的时间浪费。

有没有一种工具，我们把一箩筐的 fd 放到里面，只要有一个 fd 能够读写数据，后台 loop 线程就要立马唤醒，全部马力跑起来。其他时间要把 cpu 让出去。

### 内核实现
select poll epoll  --> 三者等级从低到高
这 3 种都能够管理 fd 的可读可写事件，在所有 fd 不可读不可写无所事事的时候，可以阻塞线程，切走 cpu 。fd 有情况的时候，都要线程能够要能被唤醒。
其实很简单，这里不详说，其实无非就是 epoll 做的无用功最少，select 和 poll 或多或少都要多余的拷贝，盲猜（遍历才知道）fd ，所以效率自然就低了。

举个例子，以 select 和 epoll 来对比举例，池子里管理了 1024 个句柄，loop 线程被唤醒的时候，select 都是蒙的，都不知道这 1024 个 fd 里谁 IO 准备好了。这种情况怎么办？只能遍历这 1024 个 fd ，一个个测试。假如只有一个句柄准备好了，那相当于做了 1 千多倍的无效功。
具体来说，select实现机制是把所有连接的io放入文件描述集合，然后调用select函数将文件描述符集合**拷贝**到内核，让内核检查有无事件产生（全部for一遍查询）， 产生了就标记一下可读或者可写，然后再**拷贝**回用户态，用户态还要遍历一遍集合。2次拷贝 2次遍历

select 线性查找 而且有fd的数量限制，1024个。而poll采用动态数组，用链表组成，突破了fd的限制。但是本质都需要遍历和2次拷贝

epoll 则不同，从 epoll_wait 醒来的时候就能精确的拿到就绪的 fd 数组，不需要任何测试，拿到的就是要处理的。

* epollcreate 负责创建一个池子，一个监控和管理句柄 fd 的池子；
* epollctl 负责管理这个池子里的 fd 增、删、改；
* epollwait 就是负责打盹的，让出 CPU 调度，但是只要有“事”，立马会从这里唤醒；

内部管理 fd 使用了高效的红黑树结构管理，做到了增删改之后性能的优化和平衡；
epoll 池添加 fd 的时候，调用 file_operations->poll ，把这个 fd 就绪之后的回调路径安排好。通过事件通知的形式，做到最高效的运行；
epoll 池核心的两个数据结构：红黑树和就绪列表。红黑树是为了应对用户的增删改需求，就绪列表是 fd 事件就绪之后放置的特殊地点，epoll 池只需要遍历这个就绪链表，就能给用户返回所有已经就绪的 fd 数组；