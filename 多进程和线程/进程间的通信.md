# 进程通信
## 进程间怎么通信
本质上来说每个进程用户地址空间是独立的，一般不能互相访问（安全等因素）。但内核空间是每个进程共享的，所以进程的通信可以借助操作系统的内核

## 管道
分为匿名管道和命名管道。所有的管道数据流向是单向的，FIFO的原则
### 匿名管道
linux 命令的 ‘|’创建

### 命名管道
mkfifo xxx 创建一个xxx的管道

### 实现机制
匿名管道的创建借助 int pipe(int fd[2])调用。


这里有个问题，2个描述符都在同一个进程里面，那么是如何进行通信的呢？
fork。    fork在创建子进程的过程中，会拷贝父进程的文件描述符号。这时候只需要对他们的文件描述符进行一定的限制就可以实现通信。
由于在shell中使用的 ｜ 操作的时候，shell会生成2个进程，这2个进程的父进程都是shell，所以说匿名管道必须是血缘关系的进行通信

命名管道则不受这个血缘关系的影响。提前创建了⼀个类型为管道的设备⽂件，在进程⾥只要使⽤这个设备⽂件，就可以相互通信。

## 消息队列
管道会发生阻塞，当接收方不接受数据的时候，发送方就会堵在那里。
消息队列的设计就出生了。
消息队列的通信模式就可以解决。⽐如， A 进程要给 B 进程发送消息， A 进程把数据放在
对应的消息队列后就可以正常返回了， B 进程需要的时候再去读取数据就可以了。同理， B 进程要给 A 进程发送消息也是如此。

### 实现机制
消息队列是保存在内核中的消息链表，在发送数据时，会分成⼀个⼀个独⽴的数据单元，也就是消
息体（数据块），消息体是⽤户⾃定义的数据类型，消息的发送⽅和接收⽅要约定好消息体的数据类型，所以每个消息体都是固定⼤⼩的存储块，不像管道是⽆格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。

### 缺点
涉及内核态和用户态的拷贝，开销大
不适合大的传输对象，因为消息体大小有上限

## 共享内存
共享内存的机制，就是拿出⼀块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写⼊的东⻄，另外⼀个进程⻢上就能看到了，都不需要拷⻉来拷⻉去，传来传去，⼤⼤提⾼了进程间通信的速度。比如，进程A和进程B的某一部分映射到相同的内存。

但这样带来的问题就是进程间的数据互斥访问。互斥访问可以利用PV信号量实现


### PV操作
信号量其实是⼀个整型的计数器，主要⽤于实现进程间的互斥与同步，⽽不是⽤于缓存进程间通信的数据。

*  ⼀个是 P 操作，这个操作会把信号量减去 1，相减后如果信号量 < 0，则表明资源已被占⽤，进程需阻塞等待；相减后如果信号量 >= 0，则表明还有资源可使⽤，进程可正常继续执⾏。

* 另⼀个是 V 操作，这个操作会把信号量加上 1，相加后如果信号量 <= 0，则表明当前有阻塞中的进程，于是会将该进程唤醒运⾏；相加后如果信号量 > 0，则表明当前没有阻塞中的进程；

针对不同的信号量初始值，有不同的操作方法。
当为1的时候，就是互斥信号量，代表只有一个进程能进入临界区。
当为0的时候，就是同步信号量，代表进程的执行顺序。

## 信号
发送给特定的信号让操作系统对进程进行操作
kill -9 1050 ，表示给 PID 为 1050 的进程发送 SIGKILL 信号，⽤来⽴即结束该进程；

## socket
用来通信2个不同主机上的进程