

# 存储引擎

Redis使用一个哈希表保存所有的 Key Value。 **内存**数据库！！！ 从内存角度来理解

哈希表随之带来的hash冲突和rehash的问题

当产生冲突时候，查找效率并不高，会变成一个On的链表，需要rehash

**rehash**具体过程（哈希表1记录数据，哈希表2并没有分配空间）

1. 哈希表2分配更大的空间
2. 哈希表1的数据映射拷贝到哈希表2中
3. 释放哈希表1

PS：原来的哈希表1将作为下次扩容的备用

但如果一次性拷贝大量的数据会造成redis线程阻塞，所以Redis用渐进式的rehash

**渐进式的rehash**

每处理一个请求，就会先将哈希表1中索引**1**中的entries拷贝到哈希表2，之后每来一个请求，哈希表1的++索引并处理。



**Value**中集合的复杂度取决于实现的数据结构

由于redis是内存数据库所以需要最大化利用内存空间，优化Cache



# 单线程的Redis

读写数据是单线程的 -- 多线程涉及资源的竞争和上下文切换。加锁解锁的消耗

Redis采用**多路复用** I/O的机制



bind/listen

accept								网络I/O

recv

parse

===========================

get						redis键值对的读写

===========================

send						网络I/O



如果一个阻塞了下面的无法进行。不采用多路复用的话。

多路复用后，一个函数阻塞后，redis会选择干其他的事情。

TODO。REVIEW epoll机制  Redis的网络模式是单reactor模式。non-blocking io + epoll

内核会监听这些套接字，当套接字由消息到达时候，会被放置到事件队列中。**Redis**只管读取这个事件队列就ok了



# Redis的数据恢复

内存数据库，掉电了，数据丢失，如何恢复。

如果直接从后端数据库中恢复，读取速度慢不说会给后端带来巨大的压力。

## AOF append only file log

AOF --- redis先把数据写入内存后，再把操作添加到log中（磁盘）

AOF中记录的是redis的每一条命令

反证法， 如果先记录到log再执行，命令失误的话，恢复的就有可能错了

AOF避免记录错误的命令，而且不会阻塞当前的写操作

**但是**AOF带来的缺点在于如果log没记录进行就挂了，数据无法及时恢复。

还有AOF会对下次redis操作带来风险，因为写入操作是在主线程中的

Redis可以配置log写盘的**时机**

1. always。 同步写会，每次写都会落盘
2. everysec。AOF log写入buff，1s后写回磁盘
3. no。 操作系统决定如何落盘



PS：AOF log不能过大，否则恢复操作需要时间长，同时追加记录也会变慢

需要对AOF进行压缩即AOF的重写。重写不是根据原有的AOF来写的，而是更具现有数据库中的值。 （子进程进行合并）

### AOF重写过程

一次拷贝，两处日志

拷贝指的是fork出子进程后，主进程会拷贝**内存**给子进程。子进程进行AOF合并 （操作系统的fork）

操作系统的copy on write 技术，只有真正写了才会copy。。  **redis的bigkey？？？** 按页来分配，默认4k，如果是bigkey会阻塞

如果操作系统开启huge page --- 2mb的页大概率会阻塞，所以要关闭这个huge page机制。



但是又有数据写入时候，第一处记录到主进程日志AOF中还有**AOF重写缓冲**中。（防止错误发生，断电后还能恢复）当子进程合并完成后加入AOF重写缓冲的部分，新的AOF替换旧的AOF。



但是利用AOF进行恢复会很慢。因为redis执行命令是单进程的。读取AOF的数据一条一条的执行，重放过程会很慢

























