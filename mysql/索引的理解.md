# 索引
## 索引划分
① 普通索引（单列索引）

② 复合索引（组合索引）

③ 唯一索引

④ 主键索引

⑤ 全文索引

## 索引须知
对于order by、group by 、 union、 distinc 中的字段出现在where条件中时，才会利用索引
尽量少以%或者_开头进行模糊查询，否则索引失效

## 主键索引
主键索引是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值


###  复合索引 （组合索引）
这里重点强调复合索引即组合索引，组合索引是使用多个字段创建的索引。复合索引遵循遵守“最左前缀”的原则。查询中使用了复合索引的第一个字段，索引才会使用。

索引项是按照索引定义里面出现的字段顺序排序的 ！！！ 理解

### 唯一索引
唯一索引和普通索引类似，但是唯一索引的值必须是唯一的，是运行空值，但是只允许一次。如果一个列中有多个空值，那么创建唯一索引会失效。但是如果有多个NULL是可以创建的，但是创建后，后续不再能传入NULL（不建议使用）。
```
# 创建单个索引 CREATE UNIQUE INDEX index_name ON table_name(col_name); 
# 多个列名和在一起
# 创建多个索引 CREATE UNIQUE INDEX index_name on table_name(col_name,...);
```

## 索引和回表
非主索引可以理解为主索引的索引，二级索引。查询的时候先从非索引树中找到主索引的值，然后进入主索引中查询 ，这一过程也叫回表操作。
回表会导致性能下降，下面介绍一些优化手法减少或者避免回表次数。

### 覆盖索引
select ID from T where k between 3 and 5
其中，ID为主索引，k为非主索引
那么查询k的索引树的时候，就已经得到了ID的值

### 最左前缀原则 
**复合索引遵守“最左前缀”原则**，**即在查询条件中使用了复合索引的第一个字段，索引才会被使用**

可以那么理解，按照联合索引的顺序进行排序，比如索引（a,b,c）索引排序先按照a进行，b进行然后c最后
可以看出建立了 （a,b,c） 索引后，可以覆盖 （a）（a，b）（a, b, c）三个索引。所以理解下来，即便只走了（a）索引 explain也会显示（a,b,c）索引的名字。这个在面试上需要特别注意的一点！！！！明确回答用了哪些索引！！！

考虑索引（name, age）索引。关于like操作，select * from like ‘张%’  and age = 10；
这个语句只能走name。
可以思考下这个例子
张三，100  张四 50， 张五 100， 张六 1.
可以看出可以利用name索引走到张这里，但是age这里是无序的，因此无法利用age索引。
理解：当走到非叶子结点的分叉路口时，张三，10 例如。进行查询的时候。无法确认走左右哪个节点。因为可能回出现左节点，张一 10， 张二 5， 张二 9； 右节点 张四 10
这样左右节点都有10 age在这里是无顺序的10，5，9，10。无法确定走哪边！！！！ 重要的，因为内部逻辑是二分查找。
而二分查找需要基于二义性，没有二义性没法使用´


### 索引下推
```
# 假定执行如下语句
# ID为主键 联合索引 （name, age）
mysql> select * from tuser where name like '张%' and age=10 and ismale=1;
```
![[索引下推0.png]]
在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。忽略了联合索引中的age。这个age判断走server层

而5.6之后索引下推中则会对age进行判断，先筛选出age等于10的ID，这样就会削减回表的次数。
那么索引的判断从server层下推到Innodb的存储引擎！！！
![[索引下推1.png]]

## 唯一索引和普通索引
在查找上效率差不多，重点在于数据的修改上。

对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入 (4,400) 这个记录，就要先判断现在表中是否已经存在 k=4 的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。