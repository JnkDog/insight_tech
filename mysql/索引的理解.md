# 索引
## 索引划分
① 普通索引（单列索引）

② 复合索引（组合索引）

③ 唯一索引

④ 主键索引

⑤ 全文索引

## 索引须知
对于order by、group by 、 union、 distinc 中的字段出现在where条件中时，才会利用索引
尽量少以%或者_开头进行模糊查询，否则索引失效

## 主键索引
主键索引是一种特殊的唯一索引，一个表只能有一个主键，不允许有空值


###  复合索引 （组合索引）
这里重点强调复合索引即组合索引，组合索引是使用多个字段创建的索引。复合索引遵循遵守“最左前缀”的原则。查询中使用了复合索引的第一个字段，索引才会使用。

索引项是按照索引定义里面出现的字段顺序排序的 ！！！ 理解

### 唯一索引
唯一索引和普通索引类似，但是唯一索引的值必须是唯一的，是运行空值，但是只允许一次。如果一个列中有多个空值，那么创建唯一索引会失效。但是如果有多个NULL是可以创建的，但是创建后，后续不再能传入NULL（不建议使用）。
```
# 创建单个索引 CREATE UNIQUE INDEX index_name ON table_name(col_name); 
# 多个列名和在一起
# 创建多个索引 CREATE UNIQUE INDEX index_name on table_name(col_name,...);
```

## 索引和回表
非主索引可以理解为主索引的索引，二级索引。查询的时候先从非索引树中找到主索引的值，然后进入主索引中查询 ，这一过程也叫回表操作。
回表会导致性能下降，下面介绍一些优化手法减少或者避免回表次数。

### 覆盖索引
select ID from T where k between 3 and 5
其中，ID为主索引，k为非主索引
那么查询k的索引树的时候，就已经得到了ID的值

### 最左前缀原则 
不大理解
**复合索引遵守“最左前缀”原则**，**即在查询条件中使用了复合索引的第一个字段，索引才会被使用**


### 索引下推
```
# 假定执行如下语句
# ID为主键 联合索引 （name, age）
mysql> select * from tuser where name like '张%' and age=10 and ismale=1;
```
![[索引下推0.png]]
在 MySQL 5.6 之前，只能从 ID3 开始一个个回表。到主键索引上找出数据行，再对比字段值。忽略了联合索引中的age。

而5.6之后索引下推中则会对age进行判断，先筛选出age等于10的ID，这样就会削减回表的次数。
![[索引下推1.png]]

## 唯一索引和普通索引
在查找上效率差不多，重点在于数据的修改上。

对于唯一索引来说，所有的更新操作都要先判断这个操作是否违反唯一性约束。比如，要插入 (4,400) 这个记录，就要先判断现在表中是否已经存在 k=4 的记录，而这必须要将数据页读入内存才能判断。如果都已经读入到内存了，那直接更新内存会更快，就没必要使用 change buffer 了。