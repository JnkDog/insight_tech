# 2PC和3PC模型理解  --- MySQL为例
## 2PC （prepare and commit）强一致性的感觉
### prepare阶段
事务管理器（协调者）发送prepare给每个资源管理器（参与者，可以简单理解为数据库实例）。这时候资源管理器会有2个状态
* 状态1：参与者本地执行事务操作，将操作写入本地的Redo和Undo Log中，此事事务不算提交，返回OK
* 状态2：事务执行失败，返回Error消息
之后进入commit阶段

### commit阶段
如果有任何失败的事务存在，则直接给成功执行的事务发送Rollback，进行事务回滚。并返回回滚成功的消息。
所有事务成功，就会发送commit给所有参与者，参与者接受消息进行本地事务提交，并将成功的消息返回给协调者。同时释放相应的锁资源。

### 如何理解确保分布式的原子性
1. 当应用程序启动分布式事务的时候，先向协调者请求一个全局唯一的分布式ID
2. 应用程序在每个参与者节点上执行单节点事务，并将单一的分布式ID附加到事务上。读写都是在单节点中完成的，如果出现问题，则可以安全阻止
3. 当应用准备提交时，协调者向所有参与者发送一个准备（prepare）请求，并打上全局事务ID的标记。如果任意一个请求失败或超时，则协调者向所有参与者发送针对该事务ID的中止请求。 -- 对应上面prepare阶段返回Error然后Rollback
4. 参与者收到准备请求时，需要确保在任意情况下都的确可以提交事务。这包括将所有事务数据写入磁盘（出现故障，电源故障，或硬盘空间不足都不能是稍后拒绝提交的理由）以及检查是否存在任何冲突或违反约束。一旦参与者向协调者回答“是”，节点承诺会提交事务。换句话说，即便没有真正的提交，参与者不会放弃已经执行的事务。
5. 当协调者收到 **所有** prepare 请求的答复时，会就提交或中止事务作出明确的决定（只有在所有参与者投赞成票的情况下才会commit）。协调者必须把这个决定写到磁盘上的事务日志中，如果它随后就崩溃，恢复后也能知道自己所做的决定。这被称为提交点（commit point）（防止协调者崩溃）。
6. 一旦协调者的决定落盘，提交或放弃请求会发送给所有参与者。如果这个请求失败或超时，协调者必须永远保持重试，直到成功为止。没有回头路：如果已经做出决定，不管需要多少次重试提交，都必须被执行。如果参与者在此期间崩溃，事务将在其恢复后提交——由于参与者投了赞成，因此恢复后参与者也要继续执行。没有反悔的余地

因此，该协议包含两个关键的“不归路”点：当参与者投票“是”时，参与者承诺肯定能够提交（尽管协调者可能仍然选择放弃，这取决于其他节点成功与否）。一旦协调者做出决定，这一决定是不可撤销的。这些承诺保证了2PC的原子性。

### 2PC故障分析
如果参与者或者网络问题。第一阶段中，任何一个prepare没有收到OK的话，那么所有参与者都会回滚。如果第二阶段，那么协调者会无限重试，直到接受所有参与者的回复。

但如果协调者出现问题，情况就很复杂。只能等待协调者恢复，并从日志中读取事务的情况。

