HTTP是位于应用层的

HTTP的下一层是传输层---- 基于TCP实现，还有个叫UDP

HTTP 是无状态的，无有记忆的。有记忆则利用cookies来实现

HTTP明文传输。不安全

HTTP 1.1 升级了长链接，TCP可持续化，优化性能



**管道传输**

只需要发送请求不需要等待,但是服务器还是会按照顺讯返回

A B C 请求

A。B。C 响应。----》 如果A不得行 那么需要等待A ===〉队头阻塞



**HTTPS**

HTTP

SSL/TLS

TCP

TCP三次握手后即可进行HTTP传输， HTTPS再三次握手后经过SSL/TLS交换，才可以加密保文传输

HTTPs需要CA



get 请求服务器资源--- 只读

post 可能会修改服务器资源

TCP保证了：

1. 无差错数据传送

2. 顺序传送
3. 未分段数据流，任意时刻以任意尺寸将数据发送



TCP得知道服务器的IP号和端口号



URL。--》 DNS ==〉 IP地址

1. URL中解析出服务器主机名
2. 主机名DNS转换为IP地址
3. 端口号抽取如果没有默认80（web服务器）
4. 浏览器和服务器建立tcp链接



先建立tcp链接再传送http报文

TCP的延迟是最大的





====== 网络层======

Ip分为网络号，主机号。网络号。--- 哪一个子网  主机号 ---- 同一子网下的不同主机

IP 还有一个能力 路由---》 决定下一个目的地



==== 数据链路层=== 

mac地址





**各个版本的HTTP的差别**

HTTP 1.1 === 长链接， 管道传输

缺点:

* 请求头没压缩
* 队头阻塞
* 优先级没控制
* 只能从客户端开始发送



HTTP 2 == 基于HTTPs，安全性有保障

* HTTP2 头部压缩，如果多个请求头部一样，消除重复部分

基于HPACK算法，client and server 同时维护一个头信息表，所有字段存入这个表生产索引，只需要发送索引即可

* 二进制传输数据

* 数据流传输，客户端数据流奇数，服务器数据流偶数 客户端可指定流的优先级 独特的flag来标志流



HTTP

HPACK  STREAM。          2.0的模型图

TLS

TCP

* 多路复用。响应可以不是顺序进行的。
* 服务器推送  服务器可以不是被动的响应， 可以主动向客户端发送数据

**HTTP2**的缺陷在于复一个TCP链接，一旦发生丢包，就会阻塞所有的HTTP请求



**HTTP3**的特点改用**UDP**传输了 ！！！

UDP上方放入**QUIC**协议，只会阻塞特定的流

之前的HTTPs建立一个链接需要3次握手 + TLS三次握手  = 6次握手

QUIC直接合并成3次了

QUIC本质是UDP之上的伪TCP + TLS + HTTP/2的多路复用



# 优化HTTP/1.1的策略

1. 将KeepAlive从短链接变为长链接

2. 避免发送HTTP请求    ---》 cache

3. 在需要发送的时候，削减请求次数

   * 减少重定向请求次数

   * 合并请求
   * 延迟发送请求

4. 减少服务器HTTP响应的数据大小

   * 压缩



## Cache

Key   -- url 

value -- response

保存在本地并由服务器在发送回本地时设置一个过期时间

如果时间过期，请求的时候需要加入**Etag头部**内部包含 ： 第一次响应头部中的摘要（待会和服务器中的摘要进行比较）

如果比较成功会返回 304 Not Modified，继续使用资源。



# 减少请求HTTP次数

1. 通过代理服务器来进行资源重定向，减少客户端发送的HTTP请求 （300相关的重定向状态码）
2. 合并小文件为大文件，减少请求次数。利用Base64对图片进行编码再由浏览器进行解码
3. 延迟发送，并不一定需要把网页全部加载出来只需要等待用户进行到特定步骤



## 无损和有损压缩

1.请求头中告诉服务器支持的编码类型

 Accept-Encoding : gzip, br

服务器返回响应头部的

content-encoding ： gzip

告诉客户端压缩的类型





# HTTPS的优化  （待填坑）



