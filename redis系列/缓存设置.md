# Redis缓存组件
## 缓存血崩
客户端无法访问Redis，导致请求全部发往数据库，导致数据库压力激增、

### 原因1：缓存中大量数据同时过期
过期时间较为一致，导致访问数据的过期后，压力来到数据库。

### 原因2：Redis实例挂了
Redis进程crash直接退出了

### 解决方案
1. 设定随机数在过期时间中，防止同时过期
2. 服务降级，非主要服务不提供服务或者默认显示，主要服务允许访问数据库
3. 前端限流
4. 主从架构切换

## 缓存击穿
频繁的热点数据没有在缓存中，导致对数据库的频繁访问。

### 原因：热点数据在缓存中过期

### 解决方案
不设置过期时间

## 缓存穿透
要访问的数据既不在Redis，也不在数据库中。做了无用功

### 解决方案
1. 一旦发生空值，就需要针对查询设置0值，防止后续的穿透
2. 布隆过滤器查看数据是否存在
3. 前端检测恶意请求

#### 布隆过滤器
bloomfilter就类似于一个hash set，用于快速判某个元素是否存在于集合中，其典型的应用场景就是快速判断一个key是否存在于某容器，不存在就直接返回。布隆过滤器的关键就在于hash算法和容器大小

## 缓存淘汰策略
redis占用内存会有一个上限,设置4G的缓存上限
```shell
redis> CONFIG SET maxmemory 4gb
```

### 为什么需要淘汰
缓存污染（或满了） 
**缓存污染问题说的是缓存中一些只会被访问一次或者几次的的数据，被访问完后，再也不会被访问到，但这部分数据依然留存在缓存中，消耗缓存空间。** 
缓存污染会随着数据的持续增加而逐渐显露，随着服务的不断运行，缓存中会存在大量的永远不会再次被访问的数据。缓存空间是有限的，如果缓存空间满了，再往缓存里写数据时就会有额外开销，影响Redis性能。这部分额外开销主要是指写的时候判断淘汰策略，根据淘汰策略去选择要淘汰的数据，然后进行删除操作。

如果写满了就需要相应的淘汰策略
Redis共支持八种淘汰策略，分别是noeviction、volatile-random、volatile-ttl、volatile-lru、volatile-lfu、allkeys-lru、allkeys-random 和 allkeys-lfu 策略。

- 不淘汰
noeviction （v4.0后默认的） 
- 对设置了过期时间的数据中进行淘汰
随机：volatile-random 
ttl：volatile-ttl 
lru：volatile-lru 
lfu：volatile-lfu 
- 全部数据进行淘汰
随机：allkeys-random 
lru：allkeys-lru 
lfu：allkeys-lfu

具体来说
* noeviction
在这种策略下，一旦缓存被写满了，再有写请求来时，Redis 不再提供服务，而是直接返回错误。这种策略不会淘汰数据。

* volatile-random 
这个算法比较简单，在设置了过期时间的键值对中，进行随机删除。因为是随机删除，无法把不再访问的数据筛选出来，所以可能依然会存在缓存污染现象，无法解决缓存污染问题。 

* volatile-ttl 
这种算法判断淘汰数据时参考的指标比随机删除时多进行一步过期时间的排序。Redis在筛选需删除的数据时，越早过期的数据越优先被选择。 

* volatile-lru 
LRU算法：LRU 算法的全称是 Least Recently Used，按照最近最少使用的原则来筛选数据。这种模式下会使用 LRU 算法筛选设置了过期时间的键值对。 Redis优化的LRU算法实现： Redis会记录每个数据的最近一次被访问的时间戳。在Redis在决定淘汰的数据时，第一次会随机选出 N 个数据，把它们作为一个候选集合。接下来，Redis 会比较这 N 个数据的 lru 字段，把 lru 字段值最小的数据从缓存中淘汰出去。通过随机读取待删除集合，可以让Redis不用维护一个巨大的链表，也不用操作链表，进而提升性能。 Redis 选出的数据个数 N，通过 配置参数 maxmemory-samples 进行配置。个数N越大，则候选集合越大，选择到的最久未被使用的就更准确，N越小，选择到最久未被使用的数据的概率也会随之减小。 volatile-lfu 会使用 LFU 算法选择设置了过期时间的键值对。 

* volatile-LFU 
算法：LFU 缓存策略是在 LRU 策略基础上，为每个数据增加了一个计数器，来统计这个数据的访问次数。当使用 LFU 策略筛选淘汰数据时，首先会根据数据的访问次数进行筛选，把访问次数最低的数据淘汰出缓存。如果两个数据的访问次数相同，LFU 策略再比较这两个数据的访问时效性，把距离上一次访问时间更久的数据淘汰出缓存。
Redis的LFU算法实现: 当 LFU 策略筛选数据时，Redis 会在候选集合中，根据数据 lru 字段的后 8bit 选择访问次数最少的数据进行淘汰。当访问次数相同时，再根据 lru 字段的前 16bit 值大小，选择访问时间最久远的数据进行淘汰。 Redis 只使用了 8bit 记录数据的访问次数，而 8bit 记录的最大值是 255，这样在访问快速的情况下，如果每次被访问就将访问次数加一，很快某条数据就达到最大值255，可能很多数据都是255，那么退化成LRU算法了。所以Redis为了解决这个问题，实现了一个更优的计数规则，并可以通过配置项，来控制计数器增加的速度。

剩下的allkeys挑选范围是所有的key，而不是单单设置了过期时间的数据。