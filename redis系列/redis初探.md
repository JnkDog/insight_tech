

# 存储引擎

Redis使用一个哈希表保存所有的 Key Value。 **内存**数据库！！！ 从内存角度来理解

哈希表随之带来的hash冲突和rehash的问题

当产生冲突时候，查找效率并不高，会变成一个On的链表，需要rehash

**rehash**具体过程（哈希表1记录数据，哈希表2并没有分配空间）

1. 哈希表2分配更大的空间
2. 哈希表1的数据映射拷贝到哈希表2中
3. 释放哈希表1

PS：原来的哈希表1将作为下次扩容的备用

但如果一次性拷贝大量的数据会造成redis线程阻塞，所以Redis用渐进式的rehash

**渐进式的rehash**

每处理一个请求，就会先将哈希表1中索引**1**中的entries拷贝到哈希表2，之后每来一个请求，哈希表1的++索引并处理。



**Value**中集合的复杂度取决于实现的数据结构

由于redis是内存数据库所以需要最大化利用内存空间，优化Cache



# 单线程的Redis

读写数据是单线程的 -- 多线程涉及资源的竞争和上下文切换。加锁解锁的消耗

Redis采用**多路复用** I/O的机制



bind/listen

accept								网络I/O

recv

parse

===========================

get						redis键值对的读写

===========================

send						网络I/O



如果一个阻塞了下面的无法进行。不采用多路复用的话。

多路复用后，一个函数阻塞后，redis会选择干其他的事情。

TODO。REVIEW epoll机制  Redis的网络模式是单reactor模式。non-blocking io + epoll

内核会监听这些套接字，当套接字由消息到达时候，会被放置到事件队列中。**Redis**只管读取这个事件队列就ok了



# Redis的数据恢复

内存数据库，掉电了，数据丢失，如何恢复。

如果直接从后端数据库中恢复，读取速度慢不说会给后端带来巨大的压力。

## AOF append only file log

AOF --- redis先把数据写入内存后，再把操作添加到log中（磁盘）

AOF中记录的是redis的每一条命令

反证法， 如果先记录到log再执行，命令失误的话，恢复的就有可能错了

AOF避免记录错误的命令，而且不会阻塞当前的写操作

**但是**AOF带来的缺点在于如果log没记录进行就挂了，数据无法及时恢复。

还有AOF会对下次redis操作带来风险，因为写入操作是在主线程中的

Redis可以配置log写盘的**时机**

1. always。 同步写会，每次写都会落盘
2. everysec。AOF log写入buff，1s后写回磁盘
3. no。 操作系统决定如何落盘



PS：AOF log不能过大，否则恢复操作需要时间长，同时追加记录也会变慢

需要对AOF进行压缩即AOF的重写。重写不是根据原有的AOF来写的，而是更具现有数据库中的值。 （子进程进行合并）

### AOF重写过程

一次拷贝，两处日志

拷贝指的是fork出子进程后，主进程会拷贝**内存**给子进程。子进程进行AOF合并 （操作系统的fork）

操作系统的copy on write 技术，只有真正写了才会copy。。  **redis的bigkey？？？** 按页来分配，默认4k，如果是bigkey会阻塞

如果操作系统开启huge page --- 2mb的页大概率会阻塞，所以要关闭这个huge page机制。



但是又有数据写入时候，第一处记录到主进程日志AOF中还有**AOF重写缓冲**中。（防止错误发生，断电后还能恢复）当子进程合并完成后加入AOF重写缓冲的部分，新的AOF替换旧的AOF。

但是利用AOF进行恢复会很慢。因为redis执行命令是单进程的。读取AOF的数据一条一条的执行，重放过程会很慢

# RDB恢复Redis （redis database）

RDB。某一时刻redis的数据保存在文件中，快照！

RDB是否会阻塞主线程 redis是单进程的

* save。 在主进程中执行，会阻塞
* bgsave。创建一个子进程写入RDB，避免了阻塞

在进行快照的时候，数据库还能修改吗？  可以 利用OS的COW机制进行，但是bgsave读取的是**修改前的数据**

连拍---RDB快照带来的开销问题

* RDB写入磁盘会带来巨大的压力
* fork() 给主进程带来的阻塞。redis拟定只有一个bgsave进行

可选方案：增量快照 ---- 在搞定全快照后，只对修改的数据进行快照的记录，但是这样记录会带来额外的空间开销

Redis使用混合AOF log 和 快照   ----  2次快照之间使用AOF记录操作

## 思考

我们使用一个 2 核 CPU、4GB 内存、500GB 磁盘的云主机运行 Redis，Redis 数据库的数据量大小差不多是 2GB，我们使用了 RDB 做持久化保证。当时 Redis 的运行负载以修改操作为主，写读比例差不多在 8:2 左右，也就是说，如果有 100 个请求，80 个请求执行的是修改操作。你觉得，在这个场景下，用 RDB 做持久化有什么风险吗？你能帮着一起分析分析吗？

修改操作多 ---》 RDB方法的缺点--- 全照 带来的缺页影响。  子进程和父进程竞争cpu的情况，继承的cou亲和属性。

TODO：REVIEW 操作系统的进程相关的知识了 ！！！

# 数据同步 Redis主从库模式

从库打命令。 replicaof   ip port。  Replica. 附属品。of。主库

1. 第一次建立链接的过程

从库发送psync命令  ----》 包含主库的runID，复制进度offest

其中runID是每个redis实例启动时产生的一个随机ID用来标记唯一实例，第一次复制因为不知道，所以为？

offset为-1，表示第一次复制

主库收到psync的命令后，会使用FULLRESYNC响应命令带上2个参数，即offest和runID。

第一次沟通代表复制采用全复制，主库会把所有数据复制给从库

2. 主库将所有数据发送给从库，即RDB文件（主库先执行bgsave，生成RDB文件，然后发送从库，从库需要清空本身所有的数据库）

   PS   主库继续写操作的时候，主库会在内存中用专门的replication buffer记录所有写操作

3. 从库接受replication buffer中的修改记录，实现主从同步

由于主库进行RDB文件产生和传输RDB是耗时的，可以采用多级主从模式即主--从--从，缓解主库的压力

* 当链接构建成功的时候，可以基于长链接的命令传播，可以避免长链接的开销
！！！ 带来了链接失效的问题

## 主从网路断开的处理
2.8以前 redis进行全量复制，开销大。
2.8以后，进行增量复制同步。全量复制需要同步所有的数据。增量复制只会把主从网络断开的命令进行接受，然后同步。





























