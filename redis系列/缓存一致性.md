# 缓存一致性
利用MySQL进行读写操作，而redis只充当只读数据库。
在进行读数据的操作的时候，优先查询redis，如果redis中没数据。MySQL查询到数据后，添加到redis中（过期时间根据业务要求设置）

那么当MySQL数据库发生数据更新怎么办。比较主流的做法是进行缓存删除。这样虽然会有问题但是可以避免一些并发带来的影响。

这里又带来了抉择到底是先删redis后修改MySQL，还是先修改MySQL再删除redis。
1. 先删除缓存，再更新MySQL
线程A更新 x = 2 （原来 x = 1）
线程A删除缓存
线程B读缓存，发现不在，从数据库读到旧数 x = 1
线程A写入新值 x = 2
线程B旧值写入 x = 1
最后缓存为x = 1，mysql 为 x = 2， 数据不一样

2. 先更新数据库，后删除缓存
缓存x不存在 数据库 x = 1  
线程A读数据库 旧值 x = 1 ,因为缓存中没有，所以A要进行添加缓存 x = 1的操作 
线程B更新数据库 x = 2
线程B删除缓存  --》本来就没有 删除个寂寞
线程A写入x = 1
最终结果 缓存 x = 1 mysql x = 2

这个情况出现概率很低。而且得满足3种情况
1. 缓存刚好失效
2. 读请求，写请求并发
3. 更新数据库 + 删除缓存的时间小于读取数据库 + 写缓存的时间。因为更新数据库需要加锁，所以大概率是慢操作
暂且采用这个方案。 
无并发请求    更新MySQL，删除缓存失败              加入重试机制，消息队列。确保删除到位
有并发请求    更新MySQL，删除缓存没开始，有并发读    等待删除完成才行


## 第二部失效问题
失效的解决思路  重试， 只要我试的次数够多就能完成。消息队列
![](./pictures/redis%E4%B8%80%E8%87%B4%E6%80%A7.png)

流程如下所示 
1. 更新数据库数据； 
2. 缓存因为种种问题删除失败 
3. 将需要删除的key发送至消息队列 
4. 自己消费消息，获得需要删除的key 继续重试删除操作，直到成功 
然而，该方案有一个缺点，对业务线代码造成大量的侵入。于是有了方案二，在方案二中，启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。